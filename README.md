# My Rust Playground

Welcome to my GitHub repository! This repository contains a collection of Rust programs, algorithms, and data structure implementations that reflect my journey in mastering Rust and exploring its applications in systems programming, blockchain, and algorithm development.

---

## üõ†Ô∏è Data Structures in Rust

Explore fundamental and advanced data structures with efficient implementations:
- **Arrays**: Basic indexed collection traversal.
- **Linked Lists**: Dynamic node-based data storage.
- **Stacks**: LIFO structure with examples like balanced parentheses.
- **Queues**: FIFO structure optimized with `VecDeque`.
- **Hash Maps**: Key-value storage for dynamic data lookup.

---

## üìö Sorting and Searching Algorithms

### **Sorting Algorithms**
| Algorithm         | Time Complexity | Space Complexity | Notes                                      |
|--------------------|-----------------|-------------------|--------------------------------------------|
| Bubble Sort       | O(n¬≤)           | O(1)             | Best for small datasets or nearly sorted arrays |
| Insertion Sort    | O(n¬≤)           | O(1)             | Efficient for small/mostly sorted datasets |
| Selection Sort    | O(n¬≤)           | O(1)             | Simplest, but not efficient for large data |
| Merge Sort        | O(n log n)      | O(n)             | Stable, good for large datasets           |
| Quick Sort        | O(n log n)      | O(log n)         | Great for random access                   |
| Heap Sort         | O(n log n)      | O(1)             | Memory efficient, optimal for constraints |

### **Searching Algorithms**
- **Linear Search**: Sequential search through an array with O(n) complexity.
- **Binary Search**: Divide and conquer on sorted arrays, with O(log n) complexity.

---

## üå≥ Tree Data Structures

| Tree Type          | Time Complexity    | Applications                        |
|--------------------|--------------------|-------------------------------------|
| Binary Trees       | O(h) for operations | Hierarchical structures             |
| Binary Search Trees | O(log n) average, O(n) worst | Ordered data storage, searching   |
| AVL Trees          | O(log n)          | Balanced BST for indexing           |
| B-Trees            | O(log n)          | File systems, database indexing     |

### Tree Traversals
- **In-Order**: Sorted output in BST.
- **Pre-Order**: Copy tree structure.
- **Post-Order**: Useful in tree deletion.
- **BFS**: Level-by-level exploration.
- **DFS**: Memory-efficient deep traversal.

---

## üß† Problem-Solving Techniques
A toolkit of techniques used for competitive programming and real-world problem-solving:
- Brute Force
- Greedy Algorithms
- Divide and Conquer
- Dynamic Programming
- Backtracking
- Sliding Window
- Two Pointers

---

## üõ†Ô∏è Advanced Data Structures

- **Tries**: Efficient for text searching and autocompletion.
- **Segment Trees**: Range query optimization.
- **Fenwick Trees**: Prefix sums for large datasets.
- **Disjoint Sets**: Efficient union-find operations for connectivity.

---

